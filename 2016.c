#pragma config(Sensor, in1,    ShoulderRobot1, sensorPotentiometer)
#pragma config(Sensor, in2,    ElbowRobot2,    sensorPotentiometer)
#pragma config(Sensor, in3,    WristRobot3,    sensorPotentiometer)
#pragma config(Sensor, in5,    ShoulderFake1,  sensorPotentiometer)
#pragma config(Sensor, in6,    ElbowFake2,     sensorPotentiometer)
#pragma config(Sensor, in7,    WristFake3,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Motor,  port1,           Slider4,       tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           Elbow2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           Shoulder1,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           Wrist3,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           outtakeServo,  tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           intakeServo,   tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           flipperMotor,  tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//int btn=0;
/*
bool oneDone = false;
bool twoDone = false;
bool threeDone = false;
bool fourDone = false;
bool fiveDone = false;
*/
task tube()
{
	while (true) {




		if(vexRT[Btn5U] == 1)		//5U to close outtake
		{//open
			setMotor(intakeServo,-127);
		}
		else
		{//close
			setMotor(intakeServo, -17);
		}
		if(vexRT[Btn6U] == 1)		//6U to close intake
		{
			setMotor(outtakeServo,70);
		}
		else
		{
			setMotor(outtakeServo, -70);
		}


		if(vexRT[Btn7U] == 1)		//7U 7D 8U 8D Flipper
		{
			//flipper 127
			motor[flipperMotor] = 20;
		}
		else if(vexRT[Btn7L] == 1)
		{
			motor[flipperMotor] = -20;
		}

		else{
			//flipper 0
			motor[flipperMotor] = 0;
		}


		//arm control using the controller

		//if (vexRT[Btn7L] == 1){
		//	motor[Elbow2] = -30;
		//}
		//else if (vexRT[Btn7R] == 1){
		//	motor[Elbow2] = 30;
	//	}
	//	else{
		//	motor[Elbow2] = 0;
		//}
		if (vexRT[Btn5D] == 1){
			motor[Wrist3] = -30;
		}
		else if (vexRT[Btn6D] == 1){
			motor[Wrist3] = 30;
		}
		else{
			motor[Wrist3] = 0;
		}






		motor[Slider4] = vexRT[Ch3]; //maps left joystick to up/down slider
	}
}

void moveTo(float mod, int shoulder, int elbow, int wrist) //method for going to macro locations
{
	//shoulder
	if(mod * (shoulder - SensorValue[ShoulderRobot1]) < 20 && mod * (shoulder - SensorValue[ShoulderRobot1])>4)
	{
		motor[Shoulder1] = 20;
	}
	else if (mod * (shoulder - SensorValue[ShoulderRobot1]) >-20&& mod * (shoulder - SensorValue[ShoulderRobot1]) <-4)
	{
		motor[Shoulder1] = -20;
	}
	else if (mod * (shoulder - SensorValue[ShoulderRobot1])>= 75)
	{
		motor[Shoulder1] = 100;
	}
	else if (mod * (shoulder - SensorValue[ShoulderRobot1]) <= -75)
	{
		motor[Shoulder1] = -100;
	}
	else
	{
		motor[Shoulder1] = mod * (shoulder - SensorValue[ShoulderRobot1]);
	}

	//elbow
	if(mod * (elbow - SensorValue[ElbowRobot2]) < 22 && mod * (elbow - SensorValue[ElbowRobot2])>5)
	{
		motor[Elbow2] = 22;
	}
	else if (mod * (elbow - SensorValue[ElbowRobot2]) >-22&& mod * (elbow - SensorValue[ElbowRobot2]) <-5)
	{
		motor[Elbow2] = -22;
	}
	else if (mod * (elbow - SensorValue[ElbowRobot2])>= 75)
	{
		motor[Elbow2] = 100;
	}
	else if (mod * (elbow - SensorValue[ElbowRobot2]) <= -75)
	{
		motor[ElbowRobot2] = -100;
	}
	else
	{
		motor[Elbow2] = mod * (elbow - SensorValue[ElbowRobot2]);
	}

	//wrist
	if(mod * (wrist - SensorValue[WristRobot3]) < 18 && mod * (wrist - SensorValue[WristRobot3])>6)
	{
		motor[Wrist3] = 25;
	}
	else if (mod * (wrist - SensorValue[WristRobot3]) >-18&& mod * (wrist - SensorValue[WristRobot3]) <-6)
	{
		motor[Wrist3] = -25;
	}
	else if (mod * (wrist - SensorValue[WristRobot3])>= 75)
	{
		motor[Wrist3] = 100;
	}
	else if (mod * (wrist - SensorValue[WristRobot3]) <= -75)
	{
		motor[Wrist3] = -100;
	}
	else
	{
		motor[Wrist3] = mod * (wrist - SensorValue[WristRobot3]);
	}
	//writeDebugStreamLine("macroLocation: %d", macroLocation);
}

float min(float a, float b)
{
return (a < b ? a : b);
}

float max(float a, float b)
{
return (a > b ? a : b);
}

float calcSpeed(float mod, int speed, int fake, int real) //calculates the speed and direction to move each motor and returns
{
	int diff = fake - real;

	if(diff < 50 && diff>0) {
		return min(mod * diff, speed * -1); //minimum speed of -10 (do tweak this number, could still jitter or not be fast enough)
	}
	else if (diff >-50 &&diff <=0)
	{
		return max(mod * diff, speed); //minimum speed of 10 (do tweak this number, could still jitter or not be fast enough)
	}
	else
	{
		return mod*(fake-real);
	}
}

task main()
{

	startTask(tube); //separate thread for claw functions

	while (true)
	{

		//log robot arm's position
		writeDebugStreamLine("real shoulder: %d", SensorValue[ShoulderRobot1]);
		writeDebugStreamLine("real elbow: %d", SensorValue[ElbowRobot2]);
		writeDebugStreamLine("real wrist: %d", SensorValue[WristRobot3]);
		//writeDebugStreamLine("macroLocation: %d", macroLocation);
		//writeDebugStreamLine("shoulder motor: %d", motor[Shoulder1]);
		//writeDebugStreamLine("elbow motor: %d", motor[Elbow2]);
		//writeDebugStreamLine("wrist motor: %d", motor[Wrist3]);

		////MACROS IN USE 2016







		if(vexRT[Btn8D]  == 1) //closest in front of robot
		{
			moveTo(0.06, 2801, 3120, 750); //mod, shoulder, elbow, wrist  CHECKED AND GOOD 1ST LOCATION
		}

		else if(vexRT[Btn8R] == 1)
		{
			moveTo(0.06, 2020, 2800, 1770); //mod, shoulder, elbow, wrist
		}

		else if(vexRT[Btn8U] ==	1)
		{
			moveTo(0.06, 1895, 2187, 2850); //mod, shoulder, elbow, wrist
		}

		else if(vexRT[Btn8L] == 1)
		{
			moveTo(0.06, 1570, 1011, 3212); //mod, shoulder, elbow, wrist
		}

		else if(vexRT[Btn7R] == 1)
		{
			moveTo(0.06, 2865, 999, 2592); //mod, shoulder, elbow, wrist
		}
		else if(vexRT[Btn7D] == 1)
		{
			moveTo(0.06, 2815, 2780, 1085); //mod, shoulder, elbow, wrist
		}
		else
		{
			motor[Wrist3] = calcSpeed(0.1, 17, SensorValue[WristFake3], SensorValue[WristRobot3]); //mod, min, fake, real .06 8
			motor[Elbow2] = calcSpeed(0.1, 14, SensorValue[ElbowFake2], SensorValue[ElbowRobot2]); //mod, min, fake, real .06 11
			motor[Shoulder1] = calcSpeed(0.1, 19, SensorValue[ShoulderFake1], SensorValue[ShoulderRobot1]); //mod, min, fake real

		}
	}
}
