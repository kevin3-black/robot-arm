#pragma config(Sensor, in1,    shoulderPot,    sensorPotentiometer)
#pragma config(Sensor, in2,    elbowPot,       sensorPotentiometer)
#pragma config(Sensor, in3,    wristPot,       sensorPotentiometer)
#pragma config(Sensor, in5,    shoulderFakePot, sensorPotentiometer)
#pragma config(Sensor, in6,    elbowFakePot,   sensorPotentiometer)
#pragma config(Sensor, in7,    wristFakePot,   sensorPotentiometer)
#pragma config(Motor,  port1,           slider,        tmotorVex393_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           elbow,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           shoulder,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           wrist,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           outtake,       tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           intake,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           flipper,       tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//CONSTANTS
#define INTAKE_OPEN -127
#define INTAKE_CLOSED -17
#define OUTTAKE_OPEN 70
#define OUTTAKE_CLOSED -70
#define FLIP_SPEED 20
#define TICK_DELAY 10

//PID GAIN CONSTANTS
#define P_S 0.2
#define I_S 0.00001
#define D_S 0

#define P_E 0.1
#define I_E 0.0001
#define D_E 0

#define P_W 0.1
#define I_W 0.00001
#define D_W 0.1

typedef struct {
    float integral; //variable for accumulating integral value
    float error; //variable to store previous error for calculating the derivative
} PIDState;

float PID(PIDState &state, float target, float current, float p, float i, float d);

task endEffectors() {
    while(true) {
        if(vexRT[Btn5U]) setMotor(intake, INTAKE_OPEN);
        else             setMotor(intake, INTAKE_CLOSED);

        if(vexRT[Btn6U]) setMotor(outtake, OUTTAKE_OPEN);
        else             setMotor(outtake, OUTTAKE_CLOSED);

        motor[flipper] =  (vexRT[Btn7U] - vexRT[Btn7L]) * FLIP_SPEED;

		motor[slider] = vexRT[Ch3]; //maps up/down slider to left joystick
    }
}

task main() {
    startTask(endEffectors);

    PIDState shoulderState; shoulderState.integral = 0; shoulderState.error = SensorValue[shoulderFakePot] - SensorValue[shoulderPot];
    PIDState elbowState; elbowState.integral = 0; elbowState.error = SensorValue[elbowFakePot] - SensorValue[elbowPot];
    PIDState wristState; wristState.integral = 0; wristState.error = SensorValue[wristFakePot] - SensorValue[wristPot];
    while(true) {
    		writeDebugStreamLine("%d", elbowState.integral);
        motor[shoulder] = PID(shoulderState, SensorValue[shoulderFakePot], SensorValue[shoulderPot], P_S, I_S, D_S);
        motor[elbow] = PID(elbowState, SensorValue[elbowFakePot], SensorValue[elbowPot], P_E, I_E, D_E);
        motor[wrist] = PID(wristState, SensorValue[wristFakePot], SensorValue[wristPot], P_W, I_W, D_W);
        sleep(TICK_DELAY);
    }
}

float PID(PIDState &state, float target, float current, float p, float i, float d) {
    float error = target - current;
    /*if (abs(state.integral) < 1000000)*/ state.integral += error * TICK_DELAY;
    float derivative = (error - state.error) / TICK_DELAY;
    state.error = error;

    return p*error + i*state.integral + d*derivative;
}
